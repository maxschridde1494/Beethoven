## Docker Compose Architecture

Beethoven's environment is defined in `docker-compose.yml`, which orchestrates several services working together. Here's an overview of each service and its role:

* **Server (Backend)** – This is the Python FastAPI application that performs the AI inference and coordinates everything. It's defined as the **"server"** service in Docker Compose. The server container is built from the provided Dockerfile (using the `server-dev` stage) and runs Uvicorn (the ASGI server) to host the FastAPI app on port **8000**. Key functions of the server: it loads your configuration from the environment, spawns background FFmpeg processes to handle video streams, and calls out to the Roboflow API for each frame (or every Nth frame as configured) to get detection results. The server then emits those results to clients via a WebSocket endpoint. It also exposes a REST API for certain things (for example, it serves the static initialization images at `/api/assets/...` and may have routes to fetch stored detections). The server depends on the database and stream proxy services (ensuring they start first). In development, the server code is mounted as a volume so you can edit it on the fly and it will auto-reload (thanks to Uvicorn's `--reload` flag).

* **Client (Frontend)** – This is the React application (built with Vite) that provides the user interface. In Docker Compose it's the **"client"** service. The client container runs the dev server on port **5173** (and uses port 3036 for Vite's HMR websocket). When you open the browser to `localhost:5173`, you're hitting this container. The client UI shows a video player for each configured camera feed and draws overlays for detections. It uses **HLS (HTTP Live Streaming)** to play the video streams and connects to the backend's WebSocket (`ws://localhost:8000/ws`) to receive real-time detection data. The video stream URL for a camera is of the form `http://localhost:8888/<cameraName>/index.m3u8`, which is served by the MediaMTX proxy. The client knows the names (like "middle-left") from the config and constructs the HLS URL accordingly. Each video player uses the `hls.js` library to handle the stream and an overlay canvas to draw bounding boxes for predictions. Like the server, the client source code is mounted into the container for live editing during development (no need to rebuild the image for frontend code changes; just save and Vite will hot-reload).

* **Stream Proxy (MediaMTX)** – The **"stream-proxy"** service runs a MediaMTX server (using the official `bluenviron/mediamtx:latest` image). MediaMTX is an open-source RTSP server that we use here to broker video streams. It accepts incoming RTSP streams (from our server's FFmpeg or directly from cameras) and makes them available as RTSP and HLS to any consumers (in this case, the web client). In the provided config (`mediamtx.yml`), HLS output is enabled on port **8888**, and a couple of stream names are predefined. For example, the config expects a stream published to the path "middle-left" (and similarly for "edge-left"). The Beethoven server, on startup, will use FFmpeg to **push any local video files** to these RTSP endpoints (e.g., it runs an FFmpeg process that reads `middle-left.mp4` and streams it to `rtsp://rtsp-proxy:8554/middle-left` inside the Docker network). MediaMTX receives that and simultaneously makes it available as an HLS stream at `http://localhost:8888/middle-left/index.m3u8` for the frontend. If instead you have MediaMTX configured to pull directly from an IP camera (using the `source:` directives), then MediaMTX itself fetches the stream and you still get HLS output. The server will in parallel open its own FFmpeg reader on the stream (either the local file or the RTSP URL) to run inference on the frames. The stream-proxy runs in the background and typically needs no direct interaction – it starts automatically and restarts if any failure occurs (configured with `restart: unless-stopped` in Compose). The MediaMTX admin console is not exposed by default here; we simply use it as a headless relay.

* **Database (PostgreSQL)** – The **"db"** service is a PostgreSQL 17 database container. It stores inference results and any other data the server might need to persist. The compose file sets it up with a default database name (`beethoven`) and credentials (username/password: `postgres`/`postgres`). These credentials correspond to the `DATABASE_URL` in the `.env` (already set to use the service hostname `db` on port 5432). In practice, the database is mainly used if you enable data persistence for detections. When `DATABASE_PERSIST_DETECTIONS` is `true`, each detection event (each time the model finds pressed keys) will be saved as a record in the DB. This can be useful for later analysis, debugging, or building a history of what was played. If you leave it `false` (the default), the server will not write detections to the database, and you can even run the system with the database turned off (though the container will still be running, idle). The database's data directory is stored in a Docker volume named **`pgdata`** so that data persists across restarts. If you ever need to reset the database to a clean state, you can stop the app and run `docker-compose down -v` to remove volumes (warning: that will delete recorded data).

* **(Optional) PGAdmin** – For convenience in development or debugging, the compose file includes a **pgAdmin 4** service definition (commented out by default). pgAdmin is a web GUI for PostgreSQL. If you want to use it, you can uncomment those lines and run compose. It will be available on port 8080 (URL: [http://localhost:8080](http://localhost:8080)) with a default login of `admin@example.com` / `postgres`. pgAdmin is not required for Beethoven to function – it's just there if you want to inspect the database contents (e.g. to verify that detections are being saved). 